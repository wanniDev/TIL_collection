# interview: equals() and hashcode()

질문: equals와 hashcode의 차이점과 언제 사용되는지에 대해 설명해주세요.

```java
equals와 hashcode는 보통 비교 대상인 두 객체의 동등성을 판단할 때 사용합니다. euqals 메소드는 두 객체가 동등한지 아닌지를 리턴하는 함수이고, 이 동등성을 판단하는 과정에서 hashcode 함수를 활용합니다. 두 메소드는 모두 동일한 객체는 동일한 값을 반환해야한다는 규칙을 가지고 있습니다. 즉, a.equals(b)가 true이면, a.hashCode()는 b.hsahCode()는 동일한 값을 리턴해야 합니다.

hashcode 메소드는 보통 해시 기반 컬렉션에서 객체를 저장하고 검색할 때 사용합니다. 즉, 비교 대상 객체의 hashcode를 반환하여, 1차로 컬렉션에 해당 객체를 포함하고 있는지를 확인하고, 만약 같은 hashcode를 가지고 있다면, 2차로 equals를 활용하여 동등성을 보장합니다. 이러한 과정을 거치는 이유는 hashcode는 각 객체에 대한 일종의 식별번호로서 정수의 형태를 가지고 있지만, 서로 다른 객체의 경우의 수는 거의 무한대이기에 간혹 다른 객체임에도 같은 hashcode를 반환할 수 있기 때문입니다.
이렇게 해시 기반 컬렉션에서 객체를 검색하는 과정에서 다른 객체임에도 같은 hashcode가 반환되는 현상을 해시 충돌이라고 합니다. 해시 기반 컬렉션의 검색 성능은 해시 충돌이 일어나는 빈도수에 반비례합니다.

# 꼬리 질문1: hash 충돌을 해결하는 방법에 대해 설명해주세요.

hash 충돌을 해결하는 방법은 크게 'separate chaining', 'open addressing'이 있습니다. 

separate chaining는 해시 맵의 버킷의 공간마다 linkedList를 구성하고, hash 충돌이 발생할 때마다 해당 버킷의 인덱스에 linkedList 노드를 추가하는 방법입니다.
open addressing는 충돌이 발생할 경우, 충돌이 발생한 버킷 인덱스 대신에 그 다음 인덱스에 저장하는 방법입니다.
Java의 HashMap에서는 이 중에서 'separate chaining'를 활용합니다. 객체의 해시코드를 버킷의 인덱스 범위안에 포함시키기 위해 modulo 연산을 활용합니다. 버킷의 분포도는 사용중인 버킷의 수와 전체 버킷 수의 비율을 뜻하는 load factor의 수치에 따라 다르며, 높을수록 해시 충돌 빈도가 높아지지만, 비어있는 버킷을 많이 확보할 수 있습니다. 반대로 낮을수록 해시 충돌 빈도는 낮아지지만 비어있는 버킷역시 줄어듭니다. 따라서 load factor의 수치가 너무 높으면 성능이 떨어지고, 너무 맞으면 메모리 낭비가 심해집니다. 
그래서 Java의 HashMap의 load factor 적정 수치인 0.75를 기본으로 지정하고 있습니다. 하지만 이는 일반적인 경우이며, 상황에 따라 개발자는 이 load factor를 적절하게 조절할 수 있어야 합니다.

# 꼬리 질문2: HashMap을 사용할 경우 발생할 수 있는 문제로 무엇이 있으며, 그 대응방안은 무엇일까요?

HashMap 컬렉션에서 다루는 데이터의 양이 극단적으로 많아질 경우, Memory Leak 이슈가 발생할 수 있습니다. 특히, Snapshot Array를 활용하기위해 HashMap을 활용하여, key 값을 스냅샷 버전으로 지정하고 value를 해당 스냅샷 버전의 array로 지정할 경우, 빈 공간이 많은 배열을 지나치게 차지할 수 있습니다.
이러한 경우, HashMap 대신의 TreeMap을 활용해볼 수 있습니다. TreeMap은 key/value Entry 쌍을 red-black 트리로 관리하여 각 노드를 이진탐색으로 검색합니다. SnapshotArray에게 할당하고자 하는 배열의 각 공간별로 TreeMap root 노드를 지정하고, snapshot을 찍을때마다 key를 snapshot버전으로, value를 해당 버전의 값을 지정하면, 기존의 해시맵을 활용하는 방법보다 공간을 더 효율적으로 활용할 수 있습니다.
```

