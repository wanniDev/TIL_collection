# InnoDB Lock

RDBMS에는 내부에 스토리지 엔진이 내장되어 있고, 해당 엔진의 규칙에 따라 데이터를 관리합니다. 대표적으로 InnoDB와 MyISAM이 있습니다. 둘의 차이점은 여러가지가 있겠지만, 가장 두드러진 차이점으로으로 트랜잭션 관리의 여부가 있겠습니다. 요즘에는 트랜잭션 관리가 전혀 필요없는 경우가 그냥 없다고 봐도 될정도라, 사실 InnoDB가 뭔지만 알아도 되겠습니다.

InnoDB에서 사용하는 락의 종류는 크게 Shared Lock(공유락), Exclusive Lock(배타락)이 있습니다.

- Shared Lock(S) : 레코드를 읽을 목적으로 트랜잭션에게 허용하는 락
- Exclusive Lock(X) : 레코드를 update, delete를 할 목적으로 트랜잭션에게 허용하는 락

네이밍에서 유추해볼 수 있듯이, 트랜잭션1에의해 S 락이 컬린 레코드는 트랜잭션2가 해당 레코드를 읽기위해 S 락을 공유하는 것을 허용합니다.
그러나, 만약 트랜잭션2가 해당 레코드를 수정하기위해 X락을 얻고자 한다면, 트랜잭션1이 S락을 반납하기 전까지는 접근이 안될 것입니다.

만약 트랜잭션1이 X락을 획득하여 특정 레코드에 접근 중이라면, 트랜잭션2는 얻고자하는 락이 X든 S든 트랜잭션1이 락을 해제하기 전까지는 접근이 불가능합니다.

이처럼 S락은 동일한 S락의 접근을 허용하지만, X락은 그 어떤 종류의 락이든 자신이 해제되기 전까지 접근을 허용하지 않습니다.

## Intention Locks

InnoDB는 세분화된 락도 지원합니다. 이는 의도에 따라 인위적으로 테이블 혹은 레코드를 대상으로 락을 획득하게 할 수 있습니다.

 [`LOCK TABLES ... WRITE`](https://dev.mysql.com/doc/refman/8.3/en/lock-tables.html)과 같은 구문을 사용할 경우, 특정 테이블에 X 락을 걸 수 있습니다. 이렇게 특정 쿼리구문을 통해 인위적으로 락을 거는 것을 Intention lock이라고 부릅니다.

사용 예를 들어보면

-  [`SELECT ... FOR SHARE`](https://dev.mysql.com/doc/refman/8.3/en/select.html) 구문은 의도적으로 공유락을 걸게되고
-  [`SELECT ... FOR UPDATE`](https://dev.mysql.com/doc/refman/8.3/en/select.html) 구문은 의도록으로 배타락을 걸게됩니다.

## Record Locks

레코드 자체만을 잠그는 것을 레코드 락(Record Locks)라고 부릅니다. InnoDB의 레코드 락은 약간의 차이가 있는데, 바로 레코드 자체가 아니라 **인덱스의 레코드**에 락을 건다는 것입니다. 인덱스를 별도로 생성하지 않은 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 락을 겁니다.
InnoDB에서는 보조 인덱스를 통해 변경 작업을 수행하느냐 혹은 pk 혹은 유니크 인덱스에 의한 변경 작업을 수행하느냐에 따라 적용되는 락이 있습니다.

- **보조 인덱스**를 이용한 변경 작업 : 넥스트 키 락(Next Key Lock), 갭 락(Gap Lock)
- **PK 혹은 유니크 인덱스**를 이용한 변경 작업 : 갭(Gap, 간격)에 대해서는 잠그진 않고 레코드 자체에 대해서만 락을 겁니다.
  - PK와 같이 유니크 특징을 보장하는 인덱스를 대상으로 수행하는 변경 작업은 정확히 단 하나의 레코드를 변경한다는 것을 보장하기 때문에 갭락을 수행할 필요가 없기 때문입니다.

## Gap Locks

갭 락은 레코드 자체가 아니라 레코드와 인접한 레코드 사이의 간격에만 락을 거는 것을 의미합니다. 갭락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어하는 것입니다.
갭락은 갭락 자체만으로 활용되기 보다는 넥스트 키 락의 일부로 자주 사용됩니다.

## Next-Key Locks

레코드 락과 갭 락을 합쳐놓은 형태의 잠금을 넥스트 키 락(Next Key Lock)이라고 합니다. 갭 락이나, 넥스트 키 락의 역할은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적입니다.

## Auto-Increment Locks

`AUTO_INCREMENT` 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야합니다. InnoDB 스토리지 엔진에서는 이를 위해 Auto increment lock 이라고 하는 테이블 수준의 락을 사용합니다.

Auto-Increment lock은 INSERT, REPLACE 쿼리문과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하며, UPDATE, DELETE 등의 쿼리에서는 걸리지 않습니다. 
이 락은 트랜잭션과 관계없이 INSERT나, REPLACE 문에서는 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제됩니다. 
이 락은 테이블에 단 하나만 존재하기 때문에, 두 개 이상의 INSERT 쿼리가 발생할 경우 하나의 쿼리가 AUTO_INCREMENT 락을 걸면 나머지 쿼리는 AUTO_INCREMENT 락을 기다려야 합니다. (참고로, INSERT 문에 AUTO_INCREMENT 컬럼에 값을 명시적으로 설정하더라도 Auto-Increment Lock은 걸게 됩니다.)

Auto-Increment lock을 명시적으로 획득하고 해제하는 방법은 없습니다. 그러나, 아주 짧은 시간동안 걸렸다가 해제되는 락이라서 대부분의 경우 문제가 되지 않습니다.

MySql 5.1 이상부터는 `innodb_autoinc_lock_mode`라는 시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경할 수 있습니다.

- innodb_autoinc_lock_mode=0
  - MySQL 5.0과 동일한 락 방식으로 모든 INSERT 문은 auto increment lock이 걸립니다.
- innodb_autoinc_lock_mode=1
  - 기존의 auto increment lock보다 가볍고 빠른 래치(뮤텍스)를 이용해 처리합니다. 그러나 대량 insert...select 문을 사용할 경우, 기존의 auto increment lock을 사용합니다.
- innodb_autoinc_lock_mode=2
  - 어떠한 경우라도 래치를 이용해 처리합니다. 그러나 연속된 자동 증가 값을 보장하진 않습니다.

## INSERT를 수행할 경우

### 단건 INSERT

- 레코드 락 : 삽입될 레코드 자체에 대한 락이 걸립니다. 생성된 레코드에 다른 트랜잭션이 접근하는 것을 막기위함입니다.
- 갭락 or 넥스트 키 락 : 특정 상황에서만 발생할 수 있습니다. 예를 들자면, 유니크 인덱스가 있는 경우, 해당 인덱스를 검색하는 동안 갭락 혹은 넥스트 키 락이 잠깐 발생할 수 있습니다. 그러나, 기본적은 단건 `INSERT` 문을 수행하는 동안에는 자주 발생하진 않습니다.
- `AUTO_INCREMENT` 락 :  `AUTO_INCREMENT` 컬럼이 있는 테이블에서 단건 `INSERT `문을 수행할 때 해당 락을 사용합니다. 여러 트랜잭션에서 `INSERT`를 수행하더라도 안전하게 값을 증가시키기 위해서입니다. 단 한건에 대한 자동 증가 값을 할당하면 되기 때문에 매우 짧습니다.

### 대량 INSERT

- 레코드 락 : 마찬가지로 다른 트랜잭션이 생되는 레코드에 접근하는 것을 막기 위해 레코드 락이 걸립니다.
- 갭 락 또는 넥스트 키 락 : 특정 간격의 인덱스에 락이 걸립니다. 대량 INSERT문의 조건에 따라 갭락이 적용될 수도 넥스트 키 락이 적용될 수도 있습니다.  대량 INSERT 작업 중에 다른 트랜잭션이 접근하여 변경하는 것을 방지합니다.
- `AUTO_INCREMENT` 잠금 : 새로 삽입되는 레코드에 대한 AUTO_INCREMENT 값을 할당하는동안 해당 락이 유지됩니다.
- `Table Locks`: 대량 삽입의 연산이 매우 크고 복잡한 경우, InnoDB에서 때때로 테이블 전체에 대한 락을 사용할 수 있습니다. 이는 일관성을 보장하고 동시성을 최소화하기 위함입니다.