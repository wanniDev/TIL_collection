# 이벤트 소싱 패턴

이벤트 소싱 패턴은 일반적으로 읽기 workload와 쓰기 workload(CQRS 패턴)을 활용하여 확장성 및 보안을 최적화하는 데 사용됩니다. **데이터는 데이터 저장소에 직접 업데이트되는 대신 일련의 이벤트로 저장됩니다.** 즉, 데이터의 현재 상태만 저장하는 대신 추가 전용 저장소를 사용하여 해당 데이터에 수행된 전체 작업을 기록합니다. 이벤트 저장소는 레코드 시스템 역할을 하머, 도메인 개체를 구체화하는 데 사용될 수 있습니다.

마이크로서비스는 이벤트 저장소의 이벤트를 재생하여 자체 데이터 스토어의 적절한 상태를 계산합니다. 패턴은 애플리케이션의 현재 상태에 대한 가시성과 애플리케이션이 해당 상태에 어떻게 도달했는지에 대한 추가 컨텍스트를 제공합니다. 이벤트 소싱 패턴은 명령 및 쿼리 데이터 저장소의 스키마가 다르더라도 특정 이벤트에 대한 데이털르 재현할 수 있기 때문에 CQRS 패턴과 효과적으로 작동합니다.

## 기존 CRUD의 제한 사항

- CRUD 시스템은 데이터 저장소에 대해 직접 업데이트 작업을 수행합니다. 이러한 작업으로 성능과 응답이 느려질 수 있으며 필요한 처리 오버헤드로 인해 확장성을 제한할 수 있습니다.
- 많은 동시 사용자가 있는 공동 작업 도메인에서 데이터 업데이트 충돌은 대체로 업데이트 작업이 단일 데이터 항목에서 수행되기 때문에 발생합니다.
- 별도의 로그에 각 작업의 세부 정보를 기록하는 다른 감사 메커니즘이 없으면 기록이 손실됩니다.

## 해결 방법

이벤트 소싱 패턴은 각각 추가 전용 저장소에 기록되는 일련의 이벤트에 의해 구동되는 데이터 작업 처리 방법을 정의합니다. 애플리케이션 코드가 데이터에서 수행된 각 작업을 명확하게 설명하는 일련의 이벤트를 이벤트 저장소로 보내며, 이벤트는 여기에 저장됩니다. 각 이벤트는 데이터에 대한 변경 집합(예: `AddedItemToOrder`)을 나타냅니다.

![image](https://github.com/wanniDev/TIL_collection/assets/81374655/df409670-585e-45ee-ab02-66edeb368388)

여기서 이벤트 저장소는 영구적인 정보 소스이므로 이벤트 데이터가 업데이트되면 안됩니다. 변경 내용을 취소하기 위해 엔티티를 업데이트하는 유일한 방법은 이벤트 저장소에 보정 이벤트를 추가하는 것입니다. 지속형 이벤트의 형식을 변경해야 하는 경우, 마이그레이션 중에 저장소의 기존 이벤트를 새 버전과 결합하기 어려울 수 있습니다.

이벤트 발행은 최소 한번일 수 있으므로 이벤트 소비자가 멱등적이어야 합니다. 이벤트가 두 번 이상 처리되는 경우 이벤트에 설명된 업데이트를 다시 적용하면 안됩니다.

선택한 이벤트 스토리지는 애플리케이션에서 생성된 이벤트 로드를 지원해야 합니다. 하나의 이벤트를 처리하면 무한 루프가 발생할 수 있으므로 하나 이상의 새 이벤트를 만드는 시나리오를 염두에 두어야 합니다.

