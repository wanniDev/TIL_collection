# 26. Remove Duplicates from Sorted Array

> https://leetcode.com/problems/remove-duplicates-from-sorted-array

오름차순으로 정렬된 배열 **nums**가 주어졌을 때 배열 내에서 중복된 숫자들을 in-place(= 주어진 배열만 사용하여)로 제거하세요. 배열은 정렬된 상태를 유지해야합니다.

특정 언어에서는 배열의 크기를 동적으로 조절할 수 없으므로 결과값은 주어진 nums 배열의 앞 부분에 위치해야합니다. 예를 들어, 중복을 제거한 뒤에 k개의 원소들이 남아있다면, nums 배열내 첫 index부터 k개의 원소들이 위치해야합니다. k개 이후의 원소들은 어떤 값이라도 관계없습니다.

추가적인 배열을 선언하지 말고 풀어야합니다. (변수는 관계없습니다)

**예제 1:**

- 입력: nums = [1,1,2]

- 출력: 2, nums = [1,2,_]

- 설명:

- - 중복 제거 후 남은 원소의 개수는 2 이므로 리턴값은 2여야합니다. 주어진 배열 nums의 첫 번째 원소는 1, 두 번째 원소는 2이어야하며 세 번째 원소는 어떤 값이라도 관계없습니다.

**예제 2:**

- 입력: nums = [0,0,1,1,1,2,2,3,3,4]

- 출력: 5, nums = [0,1,2,3,4,_,_,_,_,_]

- 설명:

- - 중복 제거 후에 5개의 원소가 남으므로 리턴값은 5여야합니다. 주어진 배열 nums는 맨 앞부터 차례로 5개의 원소(0, 1, 2, 3, 4)가 있어야하며 그 이후는 어떤 값이라도 관계없습니다.

**제약사항**

- 1 <= nums.length <= 3 * 10^4
- -100 <= nums[i] <= 100
- nums 배열은 오름차순으로 정렬되어있습니다

**구현할 method**

```java
public int removeDuplicates(int[] nums) {
  // implementation
}
```

# Solution

In-place, 즉 별도의 배열을 선언하지 않고 문제를 풀어가야 합니다. 개인적으로 배열과 관련된 문제는 별도의 배열을 선언할 수 있느냐 없느냐에 따라 난이도가 크게 차이나게 받아들여지는데요. 다행히 문제 자체는 어렵지 않은 것 같습니다.

이번 문제의 경우는 two-pointer를 활용하면 될 것 같습니다.

Write 역할을 하는 포인터와 read 역할을 하는 포인터 두개를 활용하면 되겠죠. 여기서 read는 배열을 순회하면서 읽는 역할을 수행할 것이고, write는 read가 배열을 순회하면서 특정 조건에 따라 해당 배열에 입력을 수행할 것입니다.

이번 문제의 경우에는 중복되는 배열의 element를 제거하는 것이 write 수행 조건인데, 이 조건 자체도 크게 까다롭지 않은데 심지어 친절하게 정렬까지 해주었습니다. 따라서 이 문제의 경우 배열을 순회하면서 바로 앞의 인덱스의 element가 중복이 되는지에 대한 여부만 확인하고 write를 수행하면 되겠습니다.

즉 1번 인덱스부터 배열을 순회하면서 바로 앞의 인덱스 값의 일치여부를 확인하고 만약 일치하지 않는다면 write 포인터를 한칸 앞으로 옮기고, 해당 write 포인터가 가리키는 인덱스에 read 포인터의 값을 대입하면 되겠습니다.

코드로 표현해보겠습니다.

> java

```java
class Solution {
  public int removeDuplicates(int[] nums) {
		int w = 0;
    int r = 1;
    while (r < nums.length) {
      if (nums[w] != nums[r]
        nums[++w] = nums[r];
      r++;
    }
    return w + 1;
  }
}
```

코드를 설명해보자면, read 인덱스를 1로 설정하여 순차적으로 순회하면서 write 인덱스와 값이 일치하지 않으면 write 인덱스를 한칸 옮겨서 해당 인덱스의 read 인덱스에 해당하는 값을 대입하고, 마지막에 `write 인덱스 + 1`을 리턴하도록 하였습니다.