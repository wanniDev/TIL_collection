# 88. Merge Sorted Array

두 개의 정수 배열 nums1과 nums2가 주어집니다. 두 배열은 **오름차순으로 정렬**되어 있으며 두 개의 정수 m(nums1의 원소 개수)과 n(nums2의 원소 개수)도 주어집니다.

이 때 배열 nums1과 nums2를 **오름차순인 하나의 배열**로 합치세요.

두 개의 배열을 합친 최종 결과는 함수의 리턴값이 아니라 nums1에 정렬된 상태로 저장되어 있어야 합니다. 따라서 입력으로 들어오는 nums1 배열은 m + n의 길이를 가지고, nums1 배열에서 m개의 원소 이후에는 기본값인 0으로 채워져있습니다. nums2는 n의 길이를 가진 배열이 입력으로 들어옵니다.

(문제를 풀 때 다른 배열 혹은 Collections의 자료구조를 추가로 선언하지 말고 **입력으로** **주어진 배열만 가지고** 푸세요. 변수 선언은 상관없습니다.)

**예제 1:**

- 입력: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3

- 출력: [1,2,2,3,5,6]

- 설명:

- - 배열 [1,2,3]과 [2,5,6]을 합치게 되고, 합쳐진 결과는 nums1에 오름차순으로 저장하게됩니다. 최종 배열은 [1,2,2,3,5,6]이 되며 밑줄쳐진 숫자는 nums1의 원소입니다.

**예제 2:**

- 입력: nums1 = [1], m = 1, nums2 = [], n = 0

- 출력: [1]

- 설명:

- - 배열 [1]과 빈 배열 []를 합치므로 최종 결과는 [1]만 남게됩니다.

**예제 3:**

- 입력: nums1 = [0], m = 0, nums2 = [1], n = 1

- 출력: [1]

- 설명:

- - 빈 배열 []과 배열 [1]를 합치므로 최종 결과는 [1]이 됩니다. nums1은 실제로 0개의 원소를 가지고 있지만(m = 0) 최종적으로 nums1과 nums2의 원소들이 모두 들어가야하므로 nums1 배열의 크기는 1로 주어집니다.

**예제 4:**

- 입력: nums1 = [2,5,6,7,0,0], m = 4, nums2 = [1,8], n = 2

- 출력: [1,2,5,6,7,8]

- 설명:

- - 배열 [2,5,6,7]과 [1,8]을 합치게 되고, 합쳐진 결과는 nums1에 오름차순으로 저장하게 됩니다. 최종 배열은 [1,2,5,6,7,8]이 되며 밑줄쳐진 숫자는 nums1의 원소입니다.

**제약사항:**

- nums1.length == m + n
- nums2.length == n
- 0 <= m, n <= 200
- 1 <= m + n <= 200
- -10^9 <= nums1[i], nums2[i] <= 10^9

## Solution1: Merge and Sort

num1에 m - 1 인덱스 이후로는 0으로 구성되어 있습니다. 따라서, m - 1 이후로, nums2에 해당하는 element들을 대입하고 오름차순으로 정렬하면, 조건에 맞는 해답이 생깁니다.

새로운 배열 혹은 콜렉션을 선언하지 않았으므로, 조건에도 어긋나지 않습니다.

```java
class Solution {
  public void merge(int[] nums1, int m, int[] nums2, int n) {
    for (int i = 0; i < n; i++) {
      nums1[i + m] = nums2[i];
    }
    Arrays.sort(nums1);
  }
}
```

n 만큼 순회하고 n + m 길이의 nums1을 정렬(QuickSort)를 수행하였으므로 시간 복잡도는 O((m+n)log(m+n))이 되겠습니다.

## Solution2: two pointer

**Solution1** 만으로도 충분히 좋은 해답일 수 있지만, 만약에 정렬이 불가능한 상황이 주어진다면 해당 알고리즘을 좀 더 개선해야겠습니다. nums1, 과 nums2가 이미 정렬되어있고, nums1은 m-1 번 인덱스 이후로 0으로 할당되어 있습니다.

따라서 포인터 3개를 할당하고 조건에 따라 포인터들을 역순으로 순회하면 되겠습니다.

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i1 = m - 1, i2 = n - 1, i3 = m + n - 1;
        while (i1 >= 0 && i2 >= 0) {
            if (nums1[i1] > nums2[i2]) {
                nums1[i3--] = nums1[i1--];
            } else {
                nums1[i3--] = nums2[i2--];
            }
        }
        while (i2 >= 0) {
            nums1[i3--] = nums2[i2--];
        }
    }
}
```

결과적으로 `m+n` 만큼 순회하기 때문에 O(m+n) 만큼의 시간 복잡도가 발생하여, 이전 해결책보다는 좀 더 개선되었다고 볼 수 있겠습니다.