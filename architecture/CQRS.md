# CQRS

> (Command Query Responsibility Segregation)

[Greg Young](https://twitter.com/gregyoung)에 의해 만들어진 패턴으로 데이터 저장소에 대한 읽기 및 업데이트 작업을 구분하는 패턴으로, 크게 '명령'과 '쿼리'로 역할을 분리하는 패턴입니다.

일반적으로 사용자들이 애플리케이션과 상호작용하는 주요 방식은 CRUD 저장소를 거치는 방법입니다. 가장 간단한 경우는 레코드를 저장하고 검색하는 것이지요. 그러나 사용자의 요구사항이 복잡해지면서 점차 일반적인 데이터 저장소로서의 접근 방식을 벗어나게 될 수 있습니다. 일반적인 DB의 레코드를 접하는 방식을 벗어나서 여러 레코드를 하나로 축소하거나, 다른 위치의 정보를 결합하여 가상의 레코드를 형성할 수도 있죠. 심지어 수집한 레코드를 기반으로 특정 데이터를 추론할 수도 있습니다.



![image](https://github.com/wanniDev/TIL_collection/assets/81374655/b0adae6e-5369-4ed2-96d5-c7dda3b2446f)

이러한 변화는 정보에 대한 다양한 표현을 볼 수 있게 합니다. 사용자가 정보와 상호작용할 때 그들은 이 정보의 다양한 표현을 사용합니다. 개발자들은 일반적으로 자신만의 개념 모델들을 구축하여 모델의 핵심 요소를 조작하는 데 사용합니다. 도메인 모델을 사용하는 경우, 일반적으로는 DB와 같은 영속 저장소를 개념 모델과 가까운 형태로 만듭니다.

CQRS는 위에서 이야기한 복잡한 개념적 모델을 갱신과 표시를 위한 별도의 모델로 분리하는 것을 목표로 합니다. 왜냐면 명령과 조회를 통합하여 하나의 도메인의 책임에 포함하는 행위는 복잡한 모델을 형성하게되어 명령과 조회 이 두가기 행위를 잘 수행하지 못하게 되기 때문입니다.

![image](https://github.com/wanniDev/TIL_collection/assets/81374655/57156e90-16b3-4dae-b601-6f449b7f2b75)

CQRS는 '쿼리' 모델과 '명령' 모델을 분리하여 모델별로 별도의 논리적인 프로세스 또는 별도의 하드웨어에서 실행하도록 합니다. 예를 들어 웹 애플리케이션의 경우, 사용자는 '쿼리' 모델을 통해 원하는 서비스를 접할 수 있는 웹 페이지가 렌더링된 화면을 볼 수 있습니다. 또 하나는 만약에 사용자가 게시판 등록과 같은 변경을 시도하면 해당 변경은 별도의 '명령' 모델에게 전달되며 변경된 내용은 업데이트된 상태를 렌더링하기 위해 조회 모델과 통신하게 될 것입니다.

## Misconception about CQRS

위의 내용을 보면 CQRS 패턴에서 Command 모델은 DB에서 무조건 insert만, Query 모델은 무조건 select만 넣어야 하는걸로 오해할 수도 있습니다. 이 내용은 마틴 플로어의 CQRS 문서에도 언급하고 있지만, 사용하는 어휘가 어렵고 내용도 많아서 잘 와닿지 않을 수 있어 아래와 같이 누군가가 요약해준 내용을 첨부하겠습니다.

![KakaoTalk_Photo_2023-05-19-00-09-05](https://github.com/wanniDev/TIL_collection/assets/81374655/4bf1e454-7c9c-4ea7-9562-b0f75d754c08)

굳이 또 요약하자면, CQRS는 논리적인 관점에서 읽기&쓰기를 분리하는 패턴이므로, 데이터베이스 관점에서 읽기&쓰기를 분리하는 것은 아니라는 겁니다. 즉, 회원가입 기능의 경우, 회원 테이블에 레코드를 추가하는 로직이기 때문에, CQRS 관점에서는 '명령'이 맞으며, 그 과정에서 이미 해당 계정으로 등록된 회원이 있는지 '조회'하는 것을 '쿼리'로 분리해야만 하는 것은 아니라는 것입니다.

 