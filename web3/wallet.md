# Wallet

이더리움에서 지갑은 넓게 보자면, 이더리움의 주요 사용자 인터페이스를 제공하는 소프트웨어 애플리케이션입니다. 지갑은 사용자의 암호 화폐에 대한 접근을 통제하고, 키와 주소를 관리하며, 잔액을 추적하고, 트랜잭션 생성과 서명을 제어합니다. 여기에 몇몇 이더리움 지갑은 ERC 토큰처럼 컨트랙트와 상호작용이 가능합니다.

## 지갑 이란?

**개발자 로서의 지갑(wallet)**의 의미를 살펴보면, 지갑은 사용자의 키를 보관하고 관리하기 위해 사용되는 시스템을 의미하며, 모든 지갑은 키 관리 구성요소를 가지고 있습니다. 지갑의 의미는 사용되는 플랫폼 혹은 용도에 따라, 의미가 조금씩 바뀌긴 하지만 가장 일반적인 관점에서 지갑은 **개인키를 담는 공간이자 키를 관리하는 시스템**이라 할 수 있습니다.

## 지갑 개요

지갑의 가장 중요한 포인트는 편의성과 프라이버시 사이에 균형을 맞추는 것입니다. 편의성에 치중하면, 프라이버시 침해가 심화되고, 프라이버시에 집중하면 편의성이 낮아지는 경향이 있습니다.

가장 흔한 오해가 이더리움 지갑이 이더 혹은 토큰을 보유한다는 오해입니다. 그러나 엄밀한 관점에서 지갑은 단지 키만 보유합니다. 사용자는 지갑에 있는 키로 트랜잭션을 서명함으로써 네트워크에서 토큰을 제어합니다. 이러한 맥락에서 이더리움 지갑은 키체인입니다. 사용자는 지갑의 키체인 중에서 개인키로 트랜잭션에 서명함으로서 특정 이더가 자신의 소유임을 증명합니다.

지갑은 두 가지 형태가 있는데 **비결정적 지갑, 결정적 지갑**이 있습니다.

### 비결정적(무작위) 지갑

무작위적으로 추출되는 각각의 키를 이야기합니다. 각 지갑 파일에 무작위로 추출된 단일 개인키를 저장하는 형태로 구성되어 있습니다. 그런데, 이더리움에서는 프라이버시를 최대화 하기 때문에 항상 다른 주소값으로 트랜잭션을 서명하는 방식을 권장하고 있습니다. 만약 비결정적 지갑으로 이러한 지침을 따르려고 한다면, 트랜잭션마다 새로운 지갑 파일을 생성해야하는데 이러한 방식은 트랜잭션의 횟수가 많아짐에 따라 지갑 관리가 매우 까다로워집니다.

### 결정적(시드) 지갑

결정적 지갑은 시드 혹은 마스터 키 또는 단일 시드로부터 파생된 개인키를 포함하고 있습니다. 시드는 개인키를 만들기 위해 인덱스 번호나 '체인 코드' 같은 데이터와 결합된 무작위로 추출된 번호입니다.

결정적 지갑에서 시드는 파생된 모든 키를 복구할 수 있습니다. 시드는 또한 지갑을 내보내거나 가져오기에 활용되고 있어 다른 지갑 간에 모든 키를 쉽게 이관할 수 있습니다.

이러한 구조는 편리하지만, 시드 하나로 전체 지갑에 접근이 가능하기 때문에 시드의 보안이 최우선적인 과제가 됩니다. 이 부분은 단점이 될 수도 있지만 보안을 확보하기 위한 노력은 단일 데이터에 집중할 수 있어 난이도가 줄어들 수 있다는 것은 장점이 될 수 있습니다.

#### HD 지갑(BIP-32/BIP-44)

결정적 지갑은 단일 시드로부터 아주 많은 키를 쉽게 추출하기 위해 개발었습니다. 비트코인 생태계에서 일반적으로 잘 개선된 결정적 지갑은 **BIP-32 표준**입니다. HD 지갑은 트리 구조로 파생된 키들을 가지고 있습니다. 이러한 구조는 부모 키가 자식 키의 시퀀스를 파생할 수 있고, 각각의 자식은 다시 또 손자 키의 시퀀스를 파생할 수 있습니다.

#### 시드와 니모닉 코드(BIP-39)

안전한 백업 및 검색을 위해 개인키를 인코딩하는 데는 다양한 방법이 있습니다. 가장 많이 사용되는 방법은 단어 시퀀스를 사용하는 것인데, 이는 올바른 순서로 단어 시퀀스가 입력되면 고유한 개인키를 다시 만 들 수 있습니다. 이러한 방법을 **니모닉(mnemonic)**이라 하고, 이러한 접근은 BIP-39에 의해 표준화되었습니다. 요즘 많은 이더리움 지갑은 이 표준을 사용하여 백업 및 복구를 위해 호환이 가능한 니모닉으로 '시드 가져오기' 혹은 '시드 내보내기'를 할 수 있습니다.

실용적인 측면에서 16진수 시퀀스를 기록할 때는 오류가 발생할 확률이 크지만 영 단어와 같이 사람이 읽기 쉬운 문자들을 사용하면 좀 더 다루기가 쉬워집니다. 시드는 데이터 손실 혹은 도난에 방지하기 위해선 필수적으로 필요하기 때문에 시드는 디지털 백업보다는 종이에 써서 보관할 것을 추천합니다.

요약하자면, HD 지갑의 인코딩을 위한 복구 단어 목록을 사용하는 것이 오류 없이 고쳐 쓰고, 종이에 기록하고, 읽고, 안전하게 내보내고, 개인키들을 다른 지갑으로 가져오는 가장 쉬운 방법입니다.

#### 니모닉 코드 단어

니모닉 코드 단어는 결정적 지갑을 파생하기 위해 시드로 사용되는 난수를 인코딩하는 단어 시퀀스입니다. 이 시퀀스는 지갑의 백업으로 동일하거나 호환 가능한 지갑 애플리케이션에서 모든 키를 복구하고 다시 생성하는 데 사용할 수 있습니다.

니모닉 코드는 BIP-39에 정의되어 있습니다. BIP-39는 현재 수십 개의 상호운용이 가능한 구현으로 산업계에서 광범위하게 지원을 받고 있으며, 사실상 업계 표준으로 고려되고 있습니다.

#### BIP-39 선택적 암호문

BIP-39 표준은 시드의 파생에 선택적 암호문을 사용할 수 있습니다. 

암호문을 사용하지 않으면 니모닉은 상수 문자열 "mnemonic"과 함께 솔트를 구성하여 연장되고, 주어진 니모닉으로부터 특정한 512비트 시드를 생성합니다. 

만약 암호문을 사용한다면 스트래칭 함수는 동일한 니모닉으로부터 '다른' 시드를 생성합니다. 실제로, 단일 니모닉이 주어졌을 때 암호문이 다르면 다른 시드를 만들어냅니다. 본질적으로 '잘못된' 암호문은 없습니다. 

모든 암호문은 유효하며, 각각 다른 시드를 만들어내고, 가능한 한 초기화되지 않은 많은 지갑을 형성합니다. 암호문이 충분히 복잡하고 길어서 실제로 무차별 대입 혹은 우연히 사용 중인 것을 추측할 확률도 없습니다.

선택적 암호문은 두 가지 중요한 특징을 지닙니다.

- 니모닉 자체만으로는 의미가 없도록 만들어서, 니모닉 백업이 도난으로부터 보호될 수 있도록 하는 2차 팩터로 가능합니다.
- 공격자의 협박 때문에 암호문을 가르쳐 줘야 할 경우는 진짜 암호문 대신 그럴 듯한 가짜 암호문을 제공합니다. 그러면 대부분의 자금을 담고 있는 진짜 지갑 대신 적은 양의 자금이 있는 지갑으로 공격자의 주의를 돌릴 수 있습니다.

## HD 지갑(BIP-32)과 경로(BIP-43/44)

대부분의 HD 지갑은 결정적 키 생성을 위한 산업계의 사실상 표준인 BIP-32 표준을 따릅니다.

HD 지갑에서는 **확장 키(extended key)와 강화 키(hardened key)**의 아이디어를 이해하는 것이 중요합니다.

### 확장된 공개키와 개인키

BIP-32의 용어로 말하자면, 키는 '확장'될 수 있습니다. 적절한 수학적 연산을 사용하여 확장된 '부모' 키는 '자식' 키를 파생시킬 수 있게 되고, 앞서 설명한 키와 주소의 계층 구조를 만들 수 있게 됩니다. 키를 확장하는 것은 키 자체를 가져와서 특수 체인 코드를 추가하는 것입니다. 체인 코드는 자식 키를 생성하기 위해 각 키와 혼합된 256비트 이진 문자열입니다.

만약 키가 개인키이면 접두어 `xprv`로 구분되는 **확장된 개인키(extented private key)**가 됩니다.

**확장된 공개키(extented public key)**는 접두어 `xpub`로 구분됩니다.

HD 지갑의 매우 유용한 특징은 개인키가 없는 부모 공개키에서 자식 공개키를 파생할 수 있는 능력입니다. 자식 공개키를 파생하기 위한 방법은 두 가지가 있습니다. 자식 개인키로부터 직접 파생하는 방법과 부모 공개키로부터 직접 파생하는 방법입니다.

따라서 확장된 공개키는 HD 지갑 구조의 해당 분기에서 모든 공개키를 파생하는 데 사용될 수 있습니다.

이런 방법은 매우 안전한 공개키 전용 배포를 만드는데 사용할 수 있습니다. 여기서 서버 또는 애플리케이션에는 확장된 공개키의 사본이 있지만 개인키는 없습니다. 이러한 배포는 무한한 수의 공개키와 이더리움 주소를 생성할 수 있지만, 그 주소로 보낸 돈을 쓸 수 없습니다. 한편 다른 보안 서버에서 확장된 개인키는 트랜잭션에 서명하고 돈을 사용하기 위해 관련된 모든 개인키를 파생할 수 있습니다.

#### HD 지갑 키 식별자(경로)

HD 지갑의 키는 '경로(path)' 이름 규칙을 사용하여 식별하며, 트리의 각 레벨을 `/` 문자로 구분한다. 마스터 개인키에서 파생된 개인키는 m으로 시작하며, 마스터 공개키에서 파생된 공개키는 M으로 시작한다. 따라서 마스터 개인키의 첫 번째 자식 개인키는 `m/0`이며, 첫 번째 자식 공개키는 `M/0`이다. 첫 번째 자식의 두 번째 자식은 `m/0/1`이고, 나머지도 마찬가지다.

| HD 경로       | 키 설명                                                      |
| ------------- | ------------------------------------------------------------ |
| `m/0`         | 마스터 개인키(`m`)의 첫 번째(0) 자식 개인키                  |
| `m/0/0`       | 첫 번째 자식(`m/0`)의 첫 번째 자식 개인키                    |
| `m/0'/0`      | 첫 번째 강화된 자식(`m/0`)의 첫 번째 일반 자식               |
| `m/1/0`       | 두 번째 자식(``m/1`)의 첫 번째 자식 개인키                   |
| `M/23/17/0/0` | 24번째 자식의 18번째 자식의 첫 번째 자식의 첫 번째 자식 공개키 |

키의 '조상(ancestry)'은 키를 파생한 마스터 키에 도달할 때까지 오른쪽에서 왼쪽으로 읽는다.

예를 들어, `m/x/y`의 `z`번째 자식 키는 식별자 `m/x/y/z`, `m/x`의 `y`번째 자식 키는 `m/x/y`, `m`의 `x`번째 자식 `m/x`로 표현한다.

#### HD 지갑 트리 구조 탐색

```
m / purpose' / coin_type' / account' / change / address_index
```

> BIP-44 HD 지갑 구조 예

| HD 경로            | 키 설명                                                    |
| ------------------ | ---------------------------------------------------------- |
| `M/44'/60'/0'/0/2` | 메인 이더리움 계정에 대한 세 번째 수신 공개키              |
| `M/44'/0'/3'/1/14` | 4번째 비트코인 계정의 15번째 주소 변경 공개키              |
| `m/44'/2'/0'/0/1`  | 트랜잭션 서명을 위한 라이트코인 메인 계정의 두 번째 개인키 |

