# 4장 클래스와 객체 다루기

## 클래스 정의하기

기본적으로 클래스 선언은 reference type을 정의한다. 코틀린 1.3 부터는 인라인 클래스(inline class)라는 개념이 도입되어 참조 타입이 아닌 타입을 정의할 수 있다.

## 클래스 내부 구조

```kotlin
class Person {
  var firstName: String = ""
  var familyName: String = ""
  var age: Int = 0
  
  fun fullName() = "$firstName $familyName"
  
  fun showMe() {
    println("${fullName()} : $age")
  }
}
```

자바 필드와 달리, 코틀린에서는 클라이언트 코드를 바꾸지 않아도 원하는 대로 프로퍼티 구현을 바꿀 수 있기 때문에 코틀린 프로퍼티는 캡슐화에 위배되지 않는다.

예를 들어 커스텀 getter/setter를 추가해도 클라이언트 소스코드를 바꿀 필요가 없다.

즉, `firstName` 이라는 참조는 프로퍼티가 구현되는 방법과 무관하게 항상 올바른 참조로 남을 수 있다.

기본적으로 코틀린 클래스는 공개(`public`) 가시성이다.

## 생성자

생성자는 클래스 인스턴스를 초기화해주고 인스턴스 생성 시 호출되는 특별한 함수다.

```kotlin
class Person(firstName: String, familyName: String) {
	val fullName = ""
}

fun main() {
  val person = Person("John", "Doe")
  println(person.fullName)
}
```

클래스 헤더의 파라미터 목록을 주생성자(primary constructor) 선언이라고 부른다.

주 생성자는 함수와 달리 본문이 하나가 아니다.

### 초기화 블록

초기화 블록이란 `init`이라는 키워드가 앞에 붙은 블록이다. 이 블록 안에서 클래스 초기화 시 필요한 간단하지 않은 초기화 로직을 수행할 수 있다.

```kotlin
class Person(firstName: String, familyName: String) {
  val fullName = "$firstName $familyName"
  
  init {
    println("Created new Person instance : $fullName")
  }
}
```

클래스 안에 `init` 블록이 여럿 들어갈 수 있다. 이런 경우 각 블록은 프로퍼티 초기화와 함께 순서대로 실행된다. 그리고 초기화 블록에는 `return` 문이 들어가지 못한다.

### 멤버 프로퍼티 정의

주 생성자 파라미터를 프로퍼티 초기화나 init 블록 밖에서 사용할 수는 없다.

예를 들어, 멤버 함수 내부에서는 `firstName`을 사용할 수 없다.

```kotlin
class Person(firstName: String, familyName: String) {
  val fullName = "$firstName $familyName"
  
  fun printFirstName() {
    println(firstName) // Error: firstName is not available
  }
}
```

이에 대한 해법은 생성자 파라미터의 값을 저장할 멤버 프로퍼티를 정의하는 것이다.

```kotlin
class Person(val firstName: String, familyName: String) {
  val fullName = "$firstName $familyName"
  
  fun printFirstName() {
    println(firstName)
  }
}

fun main() {
  val person = Person("John", "Doe")
  println(person.firstName)
}
```

생성자 파라미터 앞에 `val`이나 `var` 키워드를 덧붙이면, 자동으로 해당 생성자 파라미터로 초기화되는 (생성자 파라미터와 이름이 같은) 프로퍼티를 정의한다.

이 때 파라미터 이름을 프로퍼티 초기화나 `init` 블록 안에서 참조하면 생성자 파라미터를 가리키고, 다른 위치에서 참조하면 프로퍼티를 가리키게 된다.

함수와 마찬가지로 디폴트 값과 `vararg`를 생성자 파라미터에 사용할 수 있다.

```kotlin
class Person(val firstName: String, val familyName: String = "") {
  fun fullName() = "$firstName $familyName"
}

class Room(vararg val persons: Person) {
	fun showNames() {
    for (person in persons) println(person.fullName())
  }
}

fun main() {
  val room = Room(Person("John"), Person("Jame", "Smith"))
  room.showNames()
}
```

### 부 생성자

여러 생성자를 사용해 클래스 인스턴스를 서로 다른 방법으로 초기화하고 싶을 때도 있다.

이런 경우 코틀린에서는 부생성자(secondary constructor)를 사용해 해결할 수 있다.

```kotlin
class Person {
  val firstName: String
  val familyName: String
  
  constructor(firstName: String, familyName: String) {
    this.firstName = firstName
    this.familyName = familyName
  }
  
  constructor(fullName: String) {
    val names = fullName.split(" ")
    if (names.size != 2) {
      throw IllegalArgumentException("Invalid name : $fullName")
    }
    this.firstName = names[0]
    this.familyName = names[1]
  }
}
```

클래스에 주생성자를 선언하지 않은 경우, 모든 부 생성자는 자신의 본문을 실행하기 전에 프로퍼티 초기화와 `init` 블록을 실행한다.

이렇게 하면 어떤 부생성자를 호출하든지 공통적인 초기화 코드가 정확히 한 번만 실행되게 보장할 수 있다.

다른 방법으로는 부생성자가 생성자 위임 호출을 사용해 다른 부생성자를 호출하는 것이 있다. 생성자 파라미터 목록 뒤에 콜론(`:`)을 넣고 그 뒤에 일반 함수를 호출하는 것처럼 코드를 작성하되, 함수 이름 대신 `this`를 사용하면 생성자 위임 호출이 된다.

```kotlin
class Person {
  val fullName: String
  
  constructor(firstName: String, familyName: String) : this("$fisrtName $familyName")
  
  constructor(fullName: String) {
    this.fullNAme = fullName
  }
}
```

클래스에 주 생성자가 있다면, 모든 부생성자는 주 생성자에게 위임을 하거나 다른 부생성자에게 위임을 해야한다.

```kotlin
class Person(val fullName: String) {
  constructor(firstName: String, familyName: String): this("$firstName $familyName")
}
```

부 생성자의 파라미터 목록에는 `val`, `var` 키워드를 사용할 수 없다.

### 정리

코틀린 클래스에는 주, 부 생성자, 초기화 블록이 있는데, 아래 순서대로 동작한다.

1. 주생성자
2. 초기화 블록
3. 부생성자

## 널 가능성

코틀린 타입 시스템에서는 null 값이 될 수 있는 참조 타입과 널 값이 될 수 없는 참조 타입을 확실히 구분해주는 큰 장점이 있다.

이 기능은 null 발생 여부를 컴파일 시점으로 옮겨주기 때문에 악명 높은 `NullPointerException` 예외를 상반 부분 막을 수 있다.

## 널이 될 수 있는 타입

코틀린에서 기본적으로 모든 참조 타입은 **널이 될 수 없는 타입**이다.

코틀린에서 널이 될 수도 있는 값을 지정하려면 물음표(`?`)를 붙여야 한다.

```kotlin
fun isBooleanString(s: String?) = s == "false" || s == "true"
```

타입 시스템 용어에서 모든 널이 될 수 있는 타입은 원래 타입의 상위 타입이며, 원래 타입에 속하는 모든 값으로 이뤄진 집합을 `null`로 확장한 집합의 값의 집합이 된다.

즉, **널이 될 수 있는 타입의 변수**에 항상 **널이 될 수 없는 타입의 값**을 대입할 수 있다는 뜻이다. 하지만 반대의 경우는 불가능하다.

```kotlin
fun main() {
  println(isBolleanString(null)) // 가능
  val s :String? = "abc" // 가능
  val ss :String = s	// 불가능
}
```

런타임에 널이 될 수 없는 값은 실제로 널이 될 수 있는 값과 차이가 없다. 둘 사이 구분은 컴파일 수준에서만 존재한다.

코틀린 컴파일러는 널이 될 수 없는 값을 표현하기 위해 어떤 wrapper(ex: Optional)도 사용하지 않기 때문에 런타임에 어떠한 부가 비용도 들지 않는다.

널이 될 수 있는 타입은 원래 타입에 들어있는 어떤 프로퍼티나 메서드도 제공하지 않는다. 멤버 함수를 호출하거나 프로퍼티를 읽는 등의 일반적인 연산이 `null` 에서는 의미가 없기 때문이다.