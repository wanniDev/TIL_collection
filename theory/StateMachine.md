# State Machine

State machine은 Java가 태어나기 훨씬 이전부터 나온 개념입니다. State machine은 1943년 Warren McCulloch와 Walter Pitts에 의해 소개된 논문에서 나왔습니다. 이러한 개념이 생긴 이후로 Mealy Machine과 Moore Machine이 소개되었습니다.

State machine은 Finite한 스테이트, Infinite 스테이트로 분류됩니다. 그러나 현실 세계에서는 주로 Finite한 상태를 다루므로 거의 대부분 Finite State Machine을 활용합니다. Finite State Machine은 컴퓨터 프로그램과 전자 논리 회로를 설계하는 데에 쓰이는 수학적 모델이며, 유한한 개수의 상태를 갖는 오토마타, 즉 추상 기계라고 할 수 있습니다. 이러한 기계는 한 번에 오로지 한 개의 상태만을 가지며, 현재 상태(Current State)란 임의의 주어진 시간의 상태를 일컫습니다. 상태 전이란 해당 기계가 어떠한 Event에 의해 한 상태에서 다른 상태로 변화함을 뜻합니다.

주로 컴파일러, 임베디드, 게임 NPC ai에서 자주 사용됩니다. 그러나 제 경우에는 결제 상태를 다양한 상황에서 정확하게 추적하기 위해 이 개념을 익히고 활용해보고자 합니다.

## 왜 State Machine을 사용할까요?

사실 결함만 없다면, `if-else`나 `switch-case`로도 충분히 작업이 가능합니다. 하지만, 아무리 설계 자체가 결함이 없더라도, 구현 중에 변수를 요용한다던가 의도와는 다른 잘못된 플로우를 타게될 경우 원하는 결과를 얻기가 정말 어렵습니다.

특히 여러 명이 협업할 경우, 멀티스레딩/멀티프로세스 환경일 때에는 위에서 언급한 결함이 더 빈번하게 발생할 수 있습니다.

따라서 State Machine과 같이 명확한 수학적 모델을 가진 개념을 활용하면 통제 가능한 변수를 제어하여 원하는 결과를 비교적 더 수월하게 낼 수 있습니다.

## State Machine의 예시

### Moore Machine

> 예를 들어 Init State - Idle State - Processing State - Error State - Recovery State 순으로 5단계로 나뉘는 State Machine을 설계하고 구현한다고 가정해봅시다.

![image](https://github.com/wanniDev/TIL_collection/assets/81374655/cbd3d638-9618-4322-8e0f-e8bc523a664d)

`1, 2, 3`혹은 `** State`와 같이 원 내에 있는 숫자로 표시된 볼드체의 문구는 모두 'Event'이고, 알파벳으로 표시된 문구는 모두 'State' 입니다. 위의 state machine은 Moore Machine에 속하며, 오직 진입 동작만을 사용하여 전이(transition)하는 모델을 말합니다.

이 모델의 특징은 다음과 같습니다.

**장점**

1. **반드시 설계한대로만 플로우가 흐릅니다.**
   - 위 예시에서는 Init State에서 수행하는 일련의 선행작업이 수행되지 않으면, Processing State로 바로 갈 수 없습니다. 이러한 특징은 안정성을 높입니다.
   - 또한 크리티컬 에러가 발생하여 디바이스나 서버가 죽을 시에는 개발자가 대충 어느 지점에서 크리티컬 에러가 발생했는지 로그를 보지 않고도 짐작이 가능합니다. 즉, 디버깅이 빨라집니다.
2. **정해진 이벤트를 통해 상태가 전이됩니다.**
   - 설계자는 모든 플로우를 주관하여 설계할 수 있고, 구현자는 설계 문서만 보더라도 설계와 똑같은 구현이 가능해집니다.
   - 설계 자체도 단순해지며, 문서화에 걸리는 시간이 줄어듭니다.
   - 미리 전해진 이벤트의 규약이 있기 때문에, 멀티 스레딩/멀티 프로세싱 환경이나 기타 disturvance에도 오염이 되지 않습니다. 따라서 안정된 실행 환경을 보장합니다.
3. **전체적인 흐름이 유기적이며 명확합니다.**    
   - 나중에 들어온 후임자가 보더라도 코드는 명확하고 한 눈에 들어옵니다.
   - 설령 코드 구현체 자체가 복잡하더라도 설계 문서 한 장만 보면 곧바로 이해가 가능해집니다.

**단점**

1. **상태 관리가 다소 비효율적일 수 있습니다.**
   - 동일한 기능을 수행하기 위해 더 많은 상태를 필요로 할 수 있습니다. 특정 출력들을 다루기 위해 추가 상태를 도입해야할 수 있기 때문입니다.
2. **반응성의 부족**
   - 입력에 따른 즉각적인 축력 변화가 필요한 경우, 이 방식의 machine은 조금 부적절할 수 있습니다.

### Mealy Machine

![image](https://github.com/wanniDev/TIL_collection/assets/81374655/3f6b6fa3-d6a0-42de-a9bc-e367c0d03a16)

원할한 설명을 위해 가장 단순한 예시를 가져와보았습니다.

Mealy Machine은 유한 상태 기계의 한 유형입니다. 이 기계는 각 상태 전이에 따라 출력을 생성합니다. 즉, 현재 상태와 입력에 따라 출력이 결정됩니다. 다른 유한 상태 기계와 비교할 때, Mealy Machine은 Moore Machine과 가장 자주 비교됩니다. Moore Machine은 현재 상태에만 출력을 생성하는 반면, Mealy Machine은 입력과 현재 상태에 따라 출력을 생성합니다.

**장점 :**

1. **출력의 높은 반응성**
   - Mearly Machine은 입력에 따라 즉시 출력을 제공하므로 동적인 반응성을 제공합니다.
2. **상태관리의 효율성**
   - 종종 Mealy Machine은 동일한 기능을 수행하는데 더 적은 상태를 필요로 합니다. 이는 각 상태 전이에 출력이 연결되기 때문에 가능합니다.
3. **유연성**
   - 입력에 따라 동적으로 출력을 변경할 수 있기 때문에 유연성이 높습니다.

**단점 : **

1. **복잡성**
   - 출력이 상태 전이와 관련되어 있기 때문에 디자인과 구현이 복잡해질 수 있습니다.
2. **출력의 예측성**
   - 출력이 현재 상태와 입력 모두에 다라 결정되기 때문에, 시스템의 동작을 예측하는 것이 어려울 수 있습니다. 이러한 예측성의 부족은 디버깅을 어렵게 만들 수 있습니다.

## 요약

결제 상태를 추적하기 위해, 단순히 조건문을 여러 branch로 나누는 것은 오히려 애플리케이션의 복잡도 높이고 결제 데이터의 신뢰도를 낮추는 현상이 발생될 염려가 있었습니다. 그래서 정확한 결제 상태 전이를 위해, StateMachine에 대한 개념을 간단하게 짚어 보았습니다.

StateMachine 중에서 거의 유일하게 실세계에서 활용되는 Finite State Machine은 유한한 개수의 상태들 중 한 번에 하나의 상태를 가지고 특정 Event에 의해 다른 상태로 전이되는 일종의 추상 기계이며 수학적 모델입니다.

Finite State Machine을 구성하는 대표적인 모델로 Moore, Mearly machine이 있습니다. Moore Machine은 현재 상태에 기반하여 출력을 생성하는 state machine 입니다. 단순한 디자인을 구성하여 예측 가능한 동작을 제공하지만, 상태 관리의 비효율성과 출력의 반응성이 낮아 특정 응용 프로그램에서는 적절하지 않을 수 있습니다. Mealy Machine은 현재 상태와 입력 모두에 기반하여 출력을 생성하는 state machine입니다. 그래서 빠른 반응성과 상태관리의 탁월한 효율성을 보이지만, 디자인 구현의 복잡성 등의 단점이 있습니다.

결국 두 모델 중 어떤 걸 선택할지는 구현 난이도와 사용성 사이의 trade off를 고려하는 것이 관건일 듯 합니다. 결제 상태 추적에 필요한 State Machine의 모델이 무엇인지 알려면 우선 결제 상태의 변화 시나리오를 구성해보는 것이 우선일 듯 합니다.