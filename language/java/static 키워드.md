# static 키워드

static은 클래스 멤버 변수와 클래스 멤버 메서드를 선언할 때 사용되는 키워드입니다. static은 객체의 생성 없이 클래스 자체에 대한 접근이 가능합니다. 클래스 멤버 변수와 클래스 멤버 메서드는 해당 변수가 선언되는 순간 초기화가 수행 됩니다.

**static을 잘못 사용하면 생길 수 있는 문제**

static의 경우 클래스의 모든 객체들이 접근할 수 있습니다. 이러한 특징은 다음과 같은 문제점이 발생할 수 있습니다.

1. **상태 공유 문제 : **해당 클래스내의 모든 객체가 공유가 가능하기 때문에, static 상태 변수에 대한 변경은 해당 클래스의 모든 객체들에게까지 영향을 끼쳐 동시성 문제를 발생시킬 수 있습니다.
2. **객체 지향 설계 원칙 위배 : **static을 사용하면 외부에서 접근을 금지해야 하는 '캡슐화'를 위배할 수 있습니다.
3. **유지보수의 어려움 : **static 키워드를 남용하면 코드를 추적하고 수정하는 것이 어려워집니다. 특히 static 메소드는 다른 클래스에서도 호출이 가능하기 때문에, 남용하면 해당 메소드의 출처를 파악하기가 어려워집니다.

이제 3가지의 문제점을 해소하기 위한 방법들을 정리해보겠습니다.

**상태 공유 문제**

```java
public class Counter {
	public static int count = 0;
	
  public static void hit() {
    count++;
  }
}
```

위와 같은 예시를 참고하자면, `hit()` 함수는  다중 스레드 환경에서 경합이 발생할 경우, `count`상태 변수가 예기치 않은 방향으로 변경이 일어날 수 있습니다. 예를들자면, count가 0인 상태에서, 2개의 스레드가 `hit()` 함수를 동시에 실행시키킨다면, 본래는 count 변수가 2가 되어야 하는데 2개의 스레드가 count가 '0' 이었을때를 기준으로 `hit()` 함수를 실행시키는 경우가 발생하여 count가 2가 아닌 1로 반영될 수 있습니다.

따라서 상태 공유 문제를 해결하기 위해선 동기화를 처리해주어야 하는데, 가장 간단한 방법으로는 `synchronized` 키워드를 활용하여 동기화 처리를 하는 것입니다.

```java
public class Counter {
  public static int count = 0;

  public synchronized static void hit() {
      count++;
  }
}
```

다른 방법으로는 `ReentrantLock`와 같은 `Lock` 인터페이스를 활용하는 것입니다.

```java
public class Counter {
    public static int count = 0;
    private static final Lock lock = new ReentrantLock();

    public static void hit() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }
}
```

`synchronized` 방식과 `Lock` 인터페이스를 활용한 동기화 처리 방식은 몇 가지 차이점이 있는데, 차이점은 다음과 같습니다.

1. **소유 가능 여부 :** synchronized 키워드는 자바 객체에 내장된 기능으로, 해당 객체를 소유할 수 있는 스레드가 단 하나 뿐입니다. 그러나 Lock 인터페이스는 멀티 스레드에서 공유할 수 있는 락 객체를 제공하는데 이 기능은 여러 스레드에서 동시에 락을 요청할 수 있습니다.

2. **타임아웃 설정 :** synchronized 키워드는 블록 내부의 임계영역에 진입하면 다른 스레드의 접근을 허용하지 않습니다. 그런데, 만약 특정 스레드가 락을 얻은 이후 다른 스레드가 해당 블록 안에서 무한정 대기한다면, 데드락 상태에 빠질 수 있습니다. 반면에 lock 인터페이스는 tryLock()을 활용하여 일정시간 동안 락을 얻지 못하면 대기를 포기하도록 설정할 수 있습니다.

3. **조건 변수 :** lock 인터페이스는 조건 변수를 사용하여 스레드 간에 통신할 수 있는 기능을 제공합니다. 이는 synchronized 키워드로는 구현하기 어려운 다양한 상황에서의 동기화 처리를 가능하게 해줍니다.

4. **유연한 락 기능 :** lock 인터페이스는 ReentranceLock 클래스를 사용하여 구현됩니다. 이 클래스는 fair lock과 unfair lock을 모두 지원하며, 락의 해제를 위한 컨디션 큐도 제공합니다. 이러한 기능은 락의 효율성과 안정성을 높입니다.
