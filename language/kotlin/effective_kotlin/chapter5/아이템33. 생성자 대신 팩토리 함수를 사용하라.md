# 아이템 33. 생성자 대신 팩토리 함수를 사용하라

**팩토리 함수**

```kotlin
class MyLinkedList<T> (
	val head: T,
  val tail: MyLinkedList<T>?
)

// 기본 생성자 사용
val list = MyLinkedList(1, MyLinkedList(2, null))

fun <T> myLinkedListOf(
  vararg elements: T
): MyLinkedList<T>? {
  if (element.isEmpty()) return null
  
  val head = elements.copyOfRange(1, elements.size)
  val tail = myLinkedListOf(*elementsTail)
  
  return MyLinkedList(head, tail)
}

// 팩토리 함수 사용
val list = myLinkedListOf(1, 2)
```

## 팩토리 함수 장점

- 함수에 이름을 붙일 수 있다.
- 함수가 원하는 형태의 타입을 리턴할 수 있다. (ex listOf 함수)
- 호출될 때마다 새 객체를 만들 필요가 없다. (ex 싱글톤 패턴)
- 존재하지 않는 객체를 리턴할 수도 있다.
- 인라인으로 만들 수 있으며, 그 파라미터들을 reified로 만들 수 있다.
- 생성자는 즉시 슈퍼 클래스 또는 기본 생성자를 호출해야 하지만 팩토리 함수는 원하는 때에 생성자를 호출 할 수 있다.

## 팩토리 함수 종류

1. **complainon object** 함수
   - 자바 기준으로는 정적 팩토리 함수와 동일하다.
   - 경험 없는 코틀린 개발자들은 companion 객체 멤버를 단순히 정적 멤버처럼 다루지만 인터페이스 구현, 클래스를 상속받을 수도 있다.
2. 확장 팩토리 함수
   - companion 객체가 존재할 때, 객체의 함수처리 사용할 수 있는 팩토리 함수를 만들어야 할 때 사용.
3. 톱 레벨 팩토리 함수
   - 대표적인 예 listOf, setOf, mapOf
   - 안드로이드에서는 액티비티를 시작하기 위해서, 인텐트를 만드는 함수를 정의해서 사용.
4. 가짜 생성자
   - 진짜 생성자 대신에 가짜 생성자를 만드는 이유
     - 인터페이스를 위한 생성자를 만들고 싶을 때
     - reified 타입 아규먼트를 갖게 하고 싶을 때
   - 위를 제외하면, 가짜 생성자는 진짜 생성자처럼 동작해야 한다.
5. 팩토리 클래스의 메소드
   - 팩토리 클래스는 프로퍼티를 가질 수 있다. 이를 활용하면 다양한 종류로 최적화하고, 다양한 기능을 도입할 수 있다.