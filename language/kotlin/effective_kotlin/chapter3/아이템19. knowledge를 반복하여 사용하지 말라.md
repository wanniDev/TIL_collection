# 아이템19: knowledge를 반복하여 사용하지 말라

"프로젝트에서 이미 있던 코드를 복사해서 붙여넣고 있다면, 무엇인가 잘못된 것이다."

## knowlege

- knowledge는 넓은 의미로 '의도적인 정보'를 뜻하며 코드 데이터로 표현할 수 있다.
- 프로젝트를 진행할 때 정의한 모든 것이 knowlege며 알고리즘의 작동 방식, UI의 현태, 원하는 결과 등 모든 의도적인 정보를 말한다.

프로그램에서 중요한 knowlege를 크게 두 가지 뽑는다면 다음과 같다.

1. **로직 (logic) :** 프로그램이 어떠한 식으로 동작하는지와 프로그램이 어떻게 보이는지
2. **공통 알고리즘(common algorithm) : ** 원하는 동작을 하기 위한 알고리즘

둘의 차이점은 시간에 따른 변화이다. 비즈니스 로직은 시간이 지나면 변하지만, 공통 알고리즘은 한 번 정의된 이후에는 크게 변하지 않는다.

## 모든 것은 변화한다.

프로그래밍에서 유일하게 유지되는 것은 '변화한다는 속성'이라는 말이 있다. 프로젝트의 knowlege도 계속해서 변화하는데 다음과 같은 이유가 있다

- 회사가 사용자의 요구 또는 습관을 더 많이 알게 되었다.
- 디자인 표준이 변화했다.
- 플랫폼, 라이브러리, 도구 등이 변화해서 이에 대응해야 한다.

모든 것은 변화하고, 우리는 이에 대비해야하는데 변화에서 가장 큰 적은 반복되는 knowledge이다. knowledge의 반복은 프로젝트의 확장성(scalable)을 막고 쉽게 깨지게(fragile)한다.

## 언제 코드를 반복해도 될까?

추출을 통해 knowlege를 줄이면 안되는 상황이 존재한다.

얼핏보면 knowlege 반복처럼 보이지만, 실질적으로 다른 knowlege를 나타내는 부분은 추출하면 안 되는 부분이다.

> 신중하지 못한 추출은 변경을 더 어렵게 만들 수 있다.

두 코드가 같은 knowlege를 나타내는지, 다른 knowledge를 나타내는지는 다음과 같은 질문으로 알 수 있다.

- "함께 변경될 가능성이 높은가? 따로 변경될 가능성이 높은가?"
- "비즈니스 룰이 다른 곳에서 왔는가?"

잘못된 코드 추출로부터 우리를 보호할 수 있는 규칙은 `단일 책임 원칙(Single Responsibility Principle, SRP)`이다.

### 단일 책임 원칙

코드를 추출해도 되는지를 확인할 수 있는 원칙으로 단일 책임 원칙이 있다.

단일 책임 원칙이란 '클래스를 변경하는 이유는 단 한가지여야 한다.'라는 의미 이다.

두 액터(actor)가 같은 클래스를 변경하는 일은 없어야 한다. 액터란 변화를 만들어내는 존재를 말하며 서로의 업무와 분야에 대해 잘 모르는 개발자들로 비유된다.

이러한 개발자들이 같은 코드를 변경하는 것은 굉장히 위험한 일이다.

어떤 대학에서 Student라는 클래스를 가지고 있을 때, 이 클래스는 장학금과 관련된 부서와 인증과 관련된 부서에서 모두 사용된다.

두 부서에서는 Student라는 클래스에 대해서 다음과 같은 두 가지 프로퍼티를 추가했다.

- **qulifiesForScholarchip :** 장학금 관련 부서에서 만든 프로퍼티로, 학생이 장학금을 받을 수 있는 포인트를 갖고 있는지 나타낸다.
- **isPassing : **인증 관련 부서에서 만든 프로퍼티로, 학생이 인증을 통과했는지를 나타낸다.

이 두 프로퍼티는 학생의 이전 학기 성적을 기반으로 계산이 되어

개발자는 두 프로퍼티를 한꺼번에 계산하는 `calculatePointsFromPassedCourses` 함수를 만들었다.

```kotlin
class Student {
	// ...
	fun isPassing(): Boolean =
			calculatePointsFromPassedCourses() > 15

	fun qualifiesForScholarship(): Boolean =
			calculatePointsFromPassedCourses() > 30

	private fun calculatePointsFromPassedCourses(): Int {
			...
	}
}
```

그런데 "덜 중요한 과목은 장학금 포인트를 줄여달라"라는 새로운 요구사항에 의해 규칙을 바꿔야하는 상황이 생겨 파견된 다른 개발자가 이를 변경하기 위해 `qualifiesForScholarship` 프로퍼티를 확인하고, `calculatePointsFromPassedCourses()` 메소드를 수정한 후

`isPassing`도 비슷한 프로퍼티라고 생각해 이와 관련된 동작까지 수정하면 인증을 통과할 줄 알았던 학생이 통과하지 못하게 될 수있다.

개발자는 함수가 활용되고 있는 다른 부분들도 확인을 했을 것이지만 함수가 자신이 해야하는 일 이외의 책임을 갖고 있을거라는 것은 예측하지 못할 수 있다.

일반적으로 private 함수는 두 가지 이상의 역할을 하지 않기 때문에, 이러한 관습에 따라 생각했을 것이기 때문이다.

책임에 따라 StudentsIsPassingValidator와 StudentQualifiesForScholarshipValidatof를 구분해서 만들었다면

혹은 코틀린의 확장 함수를 활용하면 두 함수는 Student 클래스 아래에 두면서도, 각각의 부서가 관리하는 서로 다른 모듈 파일에 배치할 수도 있을 것이다.

```kotlin
// accreditations 모듈
fun Student.qualifiesForScholarship(): Boolean {
	...
}

// scholarship 모듈
fun Student.calculatePointsFromPassedCourses(): Boolean {
	...
}
```

헬퍼 메소드는 private 메소드로 만들지 않고, 다음과 같이 만드는 것이 일반적이다.

1. 두 부서에는 모두 사용하는 일반적인 public으로 헬퍼 메소드를 만든다. 동통 부분은 두 부서에서 모두 사용하므로, 이를 함부로 수정해서는 안되게 규약을 정한다.
2. 헬퍼 메소드를 각각의 부서 모듈에 따라 2개를 만든다.

단일 책임 원칙은 우리에게 두 가지 사실을 알려준다.

- 서로 다른 곳(위의 예에서는 서로 다른 부서)에서 사용하는 knowledge는 독립적으로 변경할 가능성이 많다. 따라서 비슷한 처리를 하더라도, 완전히 다른 knowlege로 취급하는 것이 좋다.
- 다른 knowledge는 분리해 두는 것이 좋다. 그렇지 않으면, 재사용해서는 안 되는 부분을 재사용하려는 유혹이 발생할 수 있다.

## 정리

- 모든 것은 변화한다. 따라서 공통 knowledge가 있다면, 이를 추출해서 변화에 대비해야 한다.
- 여러 요소에 비슷한 부분이 있는 경우, 변경이 필요할 때 실수가 발생할 수 있는데 이러한 부분은 추출하는 것이 좋다.
- 의도하진 않은 수정을 피하려면 또는 다른 곳에서 조작하는 부분이 있다면, 분리해서 사용하는 것이 좋다.
- 개발자는 'Don't Repeat Yourself' 라는 문장을 엄격하게 지키려고 비슷해 보이는 코드는 모두 추출하려는 경향이 있는데 극단적인 것은 언제나 좋지 않다.

시스템 설계는 예술의 영역과 비슷하기 때문에 수많은 시간과 연습이 필요하다.
