# 아이템45. 불필요한 객체 생성을 피하라

상황에 따라 객체 생성 비용은 클 수 있다.

## 객체 생성 비용은 항상 클까?

어떤 객체를 wrap할 경우 크게 3가지 비용이 든다.

1. **용량 :**
   - 현대의 64비트 JDK에서 객체는 8 바이트의 배수, `+` 앞부분은 12 바이트 헤더
   - int는 4바이트지만 Integer는 16바이트 + 레퍼런스 8바이트
2. **캡슐화된 객체의 함수 호출 비용 :** 하나하나의 비용은 크진 않지만, 티끌 모아 태산이다.
3. **객체 생성시 비용 발생 : **
   - 메모리 영역에 할당
   - 이에 대한 레퍼런스 생성 등의 비용이 발생

## 불필요한 객체를 제거할 방법

**객체 선언**

- 객체를 재사용한다. (싱글톤)

```kotlin

///////// AS-IS /////////
sealed class LinkedList<T>

class Node<T>( 
	val head: T, 
	val tail: LinkedList<T> 
): LinkedList<T>()

class Empty<T>: LinkedList<T>() // <---- 문제

// 사용
val list1: LinkedList<Int> = Node(1, Node(2, Node, Empty()) 
val list2: LinkedList<Int> = Node(3, Node(4, Node, Empty()) // Empty() 인스턴스를 매번 만들어야 함

///////// TO-BE /////////
....
object Empty : LinkedList<Nothing>() 

// 사용
val list1: LinkedList<Int> = Node(1, Node(2, Empty))
val list2: LinkedList<Int> = Node(2, Node(2, Empty)) // 하나의 Empty 인스턴스를 재활용함
```

**캐시를 활용하는 팩토리 함수**

- 팩토리 메소드를 사용하면 캐시를 가질 수 있다.
- 쓰레드 풀, 커넥션 풀 등 객체생성이 무겁고 동시에 여러 mutable 객체를 사용하는 경우 적합하다.
- 모든 순수 함수는 캐싱을 활용할 수 있다. (메모이제이션)

**예) 피보나치 수 구하는 함수**

- 한번 계산된 값은 캐싱해서 재사용된다.

```kotlin
private val FIB_CACHE = mutableMapOf<String, Conection>()

fun fib(n: Int): BigInteger = FIB_CACHE.getOrPut(n) {
  if (n <= 1) BigInteger.ONE else fib(n - 1) + fib(n - 2)
}
```

- (큰) 단점은 메모리 사용량이 늘어난다.
  - 메모리 문제로 크래시가 생기면 메모리 해제
- SoftReference를 사용하면 메모리가 필요할 때만 GC가 자동으로 메모리를 해제 해준다.
  - WeakReference는 객체를 사용하지 않으면 곧바로 제거한다.
- 캐시는 메모리와 성능의 트레이드 오프

**무거운 객체를 외부 스코프로 보내기**

- 컬렉션 처리에서 무거운 연산을 내부에서 외부 스코프로 보낸다.

  ```kotlin
  // as-is : max 연산이 element 수 만큼 수행됌
  fun <T: Comparable<T>> Iterable<T>.countMax(): Int =
  		count { it == this.max() }
  
  // to-be : max 연산은 한번만 하면 됌
  fun <T: Comparable<T>> Iterable<T>.countMax(): Int =
  		val max = this.max()
  		return count { it == max }
  }
  ```

**지연 초기화**

- 하나의 클래스에서 무거운 인스턴스들을 같이 생성해야 하는 경우

  - 해당 객체 생성이 매우 무거워 짐

    ```kotlin
    class A {
    	val b = B() // 엄청 무거움
    	val c = C() // 엄청 무거움
    	val d = D() // 엄청 무거움
    }
    
    // => A 클래스를 생성하는 일이 엄----청 무거움
    ```

  - 지연 초기화하면 사용할 때 만들어지므로 객체 생성이 가벼워진다.

    ```kotlin
    class A {
    	val b by lazy { B() } // 엄청 무거움
    	val c by lazy { C() } // 엄청 무거움
    	val d by lazy { D() } // 엄청 무거움
    }
    
    // A 클래스 생성해도 b,c,d 는 아직 생성하지 않아도 됌
    // => A 객체 생성 과정이 가벼워졌다.
    ```

  - 단점
    - 메소드 호출이 빨라야하는 경우 처음 호출하면 객체를 생성하느라 첫 호출의 응답이 오래 걸릴수도 있다.
    - 백엔드 애플리케이션에는 않좋을 수 있다. 성능 테스트도 어렵다.

**기본 자료형 사용하기**

기본 자료형을 wrap한 자료형이 사용되는 경우는 다음과 같다.

- `nullable` 타입 연산을 할 경우
- 타입을 제네릭으로 사용할 때
  - **코틀린 :** Int, Int?, List
  - **자바 : **Int, Integer, List
- 숫자 연산의 경우 기본 자료형과 wrap한 자료형의 성능 차이는 크지 않다.
  - 굉장히 큰 컬렉션을 처리할 때 차이를 확인할 수 있다.
- 자료형을 일괄 변경하면 코드를 읽기 힘들어질 수 있다.
  - 그래서 코드와 라이브러리 성능이 굉장히 중요한 경우만 최적화를 하는게 좋다
  - 그게 아니라면 큰의막 없는 최적화다.