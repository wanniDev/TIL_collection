# Kafka와 RabbitMQ의 차이점

- 일단 둘다 스트림 처리에 사용할 수 있는 메시지 대기열 시스템.
- 데이터 스트림은 고속 처리가 필요한 대용량의 연속적인 증분 데이터.
- RabbitMQ는 여러 소스에서 스트리밍 데이터를 수집하고 처리를 하기 위해 다른 대상으로 라우팅하는 분산 메시지 브로커.
- Apache Kafka는 실시간 데이터 파이프라인 및 스트리밍 애플리케이션을 구축하는 데 사용되는 스트리밍 플랫폼.

Kafka는 뛰어난 확장성과 내결함성, 내구성이 뛰어난 메시징 시스템을 제공하며 RabbitMQ보다 더 많은 기능을 갖추고 있습니다.

## 아키텍처 차이점: Kafka vs RabbitMQ

RabbitMQ와 Apache Kafka 둘다 생산자가 소비자에게 메시지를 보낼 수 있습니다.

`생산자`는 정보를 게시하는 애플리케이션, `소비자`는 정보를 구독하고 처리하는 애플리케이션입니다.

RabbitMQ와 Kafka에서 생산자와 소비자가 상호 작용하는 방식이 서로 다릅니다. 

- RabbitMQ의 생산자는 메시지를 보내고 메시지가 의도한 소비자에게 도착하는지 모니터링합니다. 비유하자면, 우편물을 받아서 수취인에게 배달하는 우체국이라 생각하면 됩니다.
- Kafka의 생산자는 소비자가 메시지를 검색했는지 여부에 관계없이 메시지를 대기열에 게시합니다.즉, 생산자가 게시하는 다양한 장르의 메시지를 진열대에 정리하는 도서관과 비슷합니다. 소비자는 진열대에 진열된 메시지를 읽고 읽은 내용을 기억합니다.

### RabbitMQ 아키텍처 접근 방식

RabbitMQ 브로커는 다음 구성 요소를 사용하여 지연 시간을 줄이고 복잡한 메시지를 분산할 수 있습니다.

- `교환소`는 생산자로부터 메시지를 수신하고 메시지를 어디로 라우팅할지 결정합니다.
- `대기열`은 교환소에서 메시지를 받아 소비자에게 보내는 스토리지 압니다.
- `바인딩`은 교환소와 브로커를 연결하는 경로입니다.

RabbitMQ에서 `라우팅 키`는 교환소에서 특정 대기열로 메시지를 라우팅하는 데 사용되는 메시지 속성입니다. 생산자가 메시지를 교환소에 보낼 때 메시지에 라우팅 키가 포함됩니다. 그러면 교환소에서는 이 라우팅 키를 사용하여 메시지를 어느 대기열로 보낼 것인지 결정합니다.

### Kafka 아키텍처 접근 방식

Kafka 클러스터는 더 복잡한 아키텍처를 사용하여 처리량이 높은 스트림 이벤트를 처리합니다. Kafka의 주요 구성 요소는 다음과 같습니다.

- ***Kafka 브로커***는 생산자가 소비자에게 데이터를 스트리밍할 수 있게 해주는 Kafka 서버입니다. Kafka 브로커에는 토픽과 해당 파티션이 포함되어 있습니다. 
- ***토픽***은 유사한 데이터를 Kafka 브로커에 그룹화하는 데이터 스토리지입니다. 
- ***파티션***은 소비자가 구독하는 토픽 내의 더 작은 데이터 스토리지입니다. 
- ***ZooKeeper***는 Kafka 클러스터와 파티션을 관리하여 내결함성 스트리밍을 제공하는 특수 소프트웨어입니다. ZooKeeper는 최근에 Apache Kafka Raft(KRaft) 프로토콜로 대체되었습니다.

***Kafka의 생산자***는 각 메시지의 메시지 키를 할당합니다. 그러면 Kafka 브로커는 해당 토픽의 선행 파티션에 메시지를 저장합니다. KRaft 프로토콜은 합의 알고리즘을 사용하여 선행 파티션을 결정합니다. 

## Kafka와 RabbitMQ의 메시징 처리 방식의 차이

- RabitMQ와 Apache Kafka는 서로 다른 방식으로 데이터를 생산자에서 소비자로 이동합니다. RabbitMQ는 end-to-end 메시지 전달의 우선 순위를 지정하는 범용 메시지 브로커입니다.
- 반면, Kafka는 서로 다른 사용 사례를 위해 설계되었으므로 서로 다른 방식으로 메시징을 처리합니다.

차이점을 좀 더 구체적으로 살펴보겠습니다.

### 메시지 사용

- **RabbitMQ : **브로커는 소비자가 메시지를 수신하게 합니다. 소비자 애플리케이션은 RabbitMQ 브로커가 메시지를 대기열로 푸시할 때까지 기다립니다.
  - 예시 : 뱅킹 애플리케이션은 중앙 거래 처리 소프트웨어의 SMS 알림을 기다립니다.
- **Kafka : **kafka 소비자는 좀 더 선제적으로 정보를 읽고 추적합니다. 메시지가 물리적 로그 파일에 추가되면 kafka 소비자는 마지막으로 읽은 메시지를 추적하고 그에 맞는 오프셋 트래커를 업데이트합니다. 여기서 오프셋 트래커는 메시지를 읽은 후 증가하는 카운터입니다. Kafka를 사용하면 생산자는 소비자가 메시지를 검색하는 것을 인식하지 못합니다.

### 메시지 우선순위

- **RabbitMQ : **브로커를 사용하면 생산자 애플리케이션은 우선 순위 대기열을 사용하여 특정 메시지를 끌어올릴 수 있습니다. 브로커는 FIFO의 순서로 메시지를 보내는 것이 맞습니다. 다만 우선 순위가 높은 메시지를 일반 메시지보다 먼저 처리합니다.
- **Kafka : **토픽과 파티션을 사용하여 메시지를 큐에 추가합니다. Kafka는 메시지를 해당 파티션에 분산할 때 모든 메시지를 동등하게 취급합니다.

### 메시지 정렬

- **RabbitMQ : **메시지를 특정 순서로 보내고 대기열에 추가합니다. 우선 순위가 더 높은 메시지가 시스템 대기열에 추가되지 않는 한 소비자는 전송된 순서대로 메시지를 받습니다.
- **Kafka : **토픽과 파티션을 사용하여 메시지를 대기열에 추가합니다. 생산자가 메시지를 보내면 해당 메시지는 특정 토픽과 파티션으로 들어갑니다.

### 메시지 삭제

- **RabbitMQ : **브로커는 메시지를 대상 대기열로 라우팅합니다. 소비자는 메시지를 읽으면 브로커에 확인(ACK) 응답을 보내고, 그러면 브로커가 대기열에서 해당 메시지를 삭제합니다.
- **Kafka : **토픽과 파티션을 사용하여 메시지를 대기열에 추가합니다. 생산자가 메시지를 보내면 해당 메시지는 특정 토픽과 파티션으로 들어갑니다. kafka는 생산자-소비자 직접 교환을 지원하지 않기 때문에 소비자는 다른 순서로 파티션에 메시지를 끌어옵니다.

## 기타 주요 차이점: Kafka vs RabbitMQ

RabbitMQ와 Kafka 둘 다 의도한 사용 사례에 맞는 고성능 메시지 전송을 지공합니다. 하지만, Kafka의 메시지 전송 용량이 RabbitMQ보다 우수합니다.

### 성능

- **RabbitMQ : **RabbitMQ의 브로커는 초당 수백만 개의 메시지를 보낼 수 있습니다. 하지만 그럴려면 브로커 여러 대가 필요합니다. RabbitMQ의 성능은 평균적으로 초당 수천 개의 메시지이며,  RabbitMQ의 대기열이 혼잡하면 속도가 느려질 수 있습니다.
- **Kafka : **순차 디스크 I/O를 사용하여 처리량이 높은 메시지를 교환할 수 있으므로 초당 수백만 개의 메시지를 전송할 수 있습니다. 순차 디스크 I/O는 인접한 메모리 공간의 데이터를 저장하고 액세스하는 스토리지 시스템으로 랜덤 디스크 액세스보다 빠릅니다.

### 보안

RabbitMQ의 Kafka를 사용하면 애플리케이션이 서로 다른 기술을 사용하여 메시지를 안전하게 교환할 수 있습니다.

- **RabbitMQ : **사용자 권한 및 브로커 보안을 관리하는 관리 도구가 함께 제공됩니다.
- **Apache kafka : **해당 아키텍처는 TLS와 Java Authentication and Authorization Service(JAAS)를 통해 안전한 이벤트 스트림을 제공합니다. TLS는 의도하지 않은 메시지 도청을 방지하는 암호화 기술이고, JAAS는 브로커 시스템에 액세스할 수 있는 애플리케이션을 제어합니다.

### 프로그래밍 언어 및 프로토콜

Kafka와 RabbitMQ 둘 다 개발자에게 친숙한 다양한 언어, 프레임워크 및 프로토콜을 지원합니다.

- **RabbitMQ : **
  - 클라이언트 애플리케이션 빌드시 Java, Ruby로 코딩할 수 있습니다. JavaScript, Go, C, Swift, Spring, Elixir, PHP, .Net을 지원합니다.
  - RabbitMQ는 **Advenced Message Queuing Protocol(AMQP)**을 지원합니다. RabbitMQ도 메시지를 라우팅하기 위한 **Simple Text Oriented Messaging Protocol(STOMP)** 및 MQTT와 같은 레거시 프로토콜을 지원삽니다.
- **Kafka : **
  - 클라이언트 애플리케이션 빌드시 Java, Ruby로 코딩할 수 있습니다. 지원하는 언어로는 Python, Node.js 입니다.
  - TCP를 통한 바이너리 프로토콜을 사용하여 실시간 데이터 파이프라인에서 메시지를 스트리밍 합니다.

## Kafka와 RabbitMQ의 유사점은 무엇인가?

애플리케이션은 클라우드에서 데이터를 교환하려면 신뢰할 수 있는 메시지 브로커가 필요합니다. RabbitMQ와 Kafka는 점점 증가하는 트래픽 수요와 고가용성을 충족하도록 확장 가능하고 내결함성이 뛰어난 플랫폼을 제공합니다.

이 둘의 주요 유사점은 다음과 같습니다.

### 확장성

- **RabbitMQ : ** 
  - 메시지 처리 용량을 수평 및 수직으로 확장할 수 있습니다.
  - 서버에 더 많은 컴퓨팅 리소스를 할당하여 메시지 교환 효율을 높일 수 있습니다.
  - 상황에 따라 개발자는 *RabbitMQ 일관성 해시 교환*이라는 메시지 분산 기술을 사용하여 브로커 간의 부하 처리 균형을 맞춥니다.
- **Kafka :**
  - 특정 토픽에 더 많은 파티션을 추가하여 메시지 부하를 균등하게 분산할 수 있습니다.

### 내결함성

Kafka와 RabbitMQ 둘 다 시스템 장애에 대한 복원력이 뛰어난 강력한 메시지 큐 아키텍처입니다.

- **RabbitMQ : **여러 브로커를 클러스터로 그룹화하여 여러 서버에 배포할 수 있습니다. 또한 RabbitMQ는 대기열에 있는 모든 메시지를 모든 분산 노드에 복제합니다.
- **Kafka : **kafka 클러스터를 여러 서버에 호스팅하여 유사한 복구성과 중복성을 공유합니다. 각 클러스터는 장애 발생 시 복구할 수 있는 로그 파일 복제본으로 구성됩니다.

### 사용 편의성 

두 메시지 큐 시스템 모두 강력한 커뮤니티 지원 기능과 메시지를 간편하게 보내고 일고 처리할 수 있는 라이브러리를 갖추고 있습니다. 따라서 두 시스템 모두 클라이언트 애플리케이션을 쉽게 개발할 수 있습니다.

예를 들어 kafka Streams(클라이언트 라이브러리)를 사용하여 Kafka와 Spring Cloud Data Flow에서 메시징 시스템을 구축하여 RabbitMQ도 이벤트 기반 마이크로서비스를 구축할 수 있습니다.

## Kafka와 RabbitMQ의 사용 시기

RabbitMQ와 Kafka는 서로 경쟁하는 메시지 브로커가 아니라는 점을 이해해야 합니다. RabbitMQ와 Kafka는 둘 중 하나가 더 적합한 여러 사용 사례에서 데이터 교환을 지원하도록 설계되었습니다.

다음으로, RabbitMQ 및 Kafka와 관련하여 고려해야 할 몇 가지 사용 사례를 살펴보겠습니다.

### 이벤트 스트림 재생

- **Kafka**는 수신된 데이터를 다시 분석해야하는 애플리케이션에 적합합니다. 보존 기간 내에 스트리밍 데이터를 여러 번 처리할 수도 있고 로그 파일을 수집하여 분석할 수도 있습니다.
- **RabbitMQ**의 경우 사용된 메시지는 삭제되기 때문에 로그를 집계하기는 더 어렵습니다. 해결 방법은 생산자가 저장한 메시지를 재생하는 겁니다.

### 실시간 데이터 처리

- **Kafka**는 메시지를 스트리밍할 때 지연 시간이 매우 짧기 때문에 스트리밍 데이터를 실시간으로 분석하는 데 적합합니다. 예를 들어 kafka를 분산 모니터링 서비스로 사용하여 온라인 트랜잭션 처리 알림을 실시간으로 생성할 수 있습니다.

### 복잡한 라우팅 아키텍처

- **RabbitMQ**는 요구 사항이 모호하거나 라우팅 시나리오가 복잡한 클라이언트에게 유연성을 제공합니다. 
- 예를 들어 바인딩과 교환이 서로 다른 애플리케이션으로 데이터를 라우팅하도록 RabbitMQ를 설정할 수 있습니다.

### 효과적인 메시지 전달

- **RabbitMQ**는 푸시 모델을 적용합니다. 
- 즉, 생산자는 클라이언트 애플리케이션이 메시지를 사용했는지 여부를 알 수 있습니다. 
- 데이터를 교환하고 분석할 때 특정 순서 및 전달 보장을 준수해야 하는 애플리케이션에 적합합니다. 

### 언어 및 프로토콜 지원

- 개발자는 MQTT 및 STOMP와 같은 레거시 프로토콜과 호환되어야 하는 클라이언트 애플리케이션에 RabbitMQ를 사용합니다. 
- 또한 RabbitMQ는 Kafka에 비해 더 많은 프로그래밍 언어를 지원합니다.

## Kafka는 RabbitMQ를 사용하나요?

Kafka는 RabbitMQ를 사용하지 않습니다. RabbitMQ를 사용하지 않고 실시간 이벤트 스트림을 분산하는 독립 메시지 브로커입니다. 둘 다 서로 독립적으로 작동하는 별도의 데이터 교환 시스템입니다.

그러나 일부 개발자는 RabbitMQ 네트워크에서 Kafka로 메시지를 라우팅합니다. 기존 RabbitMQ 데이터 파이프라인을 해체하고 Kafka로 재구축하려면 더 많은 노력이 필요하기 때문입니다. 

## 차이점 요약: Kafka vs RabbitMQ

|                             | RabbitMQ                                                     | Kafka                                                        |
| --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 아키텍처                    | RabbitMQ의 아키텍처는 복잡한 메시지 라우팅을 위해 설계되었습니다. 푸시 모델을 사용합니다. 생산자는 다른 규칙을 사용하여 소비자에게 메시지를 보냅니다. | Kafka는 처리량이 많은 스트림을 실시간으로 처리하기 위해 파티션 기반 설계를 사용합니다. 풀 모델을 사용합니다. 생산자는 소비자가 구독하는 토픽과 파티션에 메시지를 게시합니다. |
| 메시지 처리                 | RabbitMQ 브로커는 메시지 사용을 모니터링합니다. 메시지가 사용되면 RabbitMQ 브로커는 사용된 메시지를 삭제합니다. RabbitMQ 브로커는 메시지 우선 순위를 지원합니다. | 소비자는 오프셋 트래커를 사용하여 메시지 검색을 추적합니다. Kafka는 보존 정책에 따라 메시지를 보관합니다. 메시지 우선 순위가 없습니다. |
| 성능                        | RabbitMQ는 지연 시간이 짧습니다. 초당 수천 개의 메시지를 전송합니다. | Kafka는 초당 최대 수백만 개의 메시지를 실시간으로 전송합니다. |
| 프로그래밍 언어 및 프로토콜 | RabbitMQ는 광범위한 언어 및 레거시 프로토콜을 지원합니다.    | Kafka는 프로그래밍 언어 선택의 폭이 제한적입니다. TCP를 통한 바이너리 프로토콜을 데이터 전송에 사용합니다. |